#include <iterator>using namespace std;template<class T>class Circle_buf{public:    class Iterator : public iterator<random_access_iterator_tag, T>{    private:        T *s;    public:        Iterator(T *data){            s = data;        }//        Iterator(const Iterator &it): s(it.s){//        }        Iterator operator+  (int x){            return Iterator(s+x);        }        T  operator-  (Circle_buf buf){            return s - buf.s;        }        Iterator operator- (int x){            return Iterator(s-x);        }        Iterator &operator+= (int x){            s += x;            return *this;        }        Iterator &operator-= (T x){            s -= x;            return *this;        }        Iterator &operator++(){            s++;            return *this;        }        Iterator &operator--(){            s--;            return *this;        }        Iterator operator++(int){            Iterator tmp = *this;            ++(*this);            return tmp;        }        Iterator operator--(T){            Iterator t(*this);            s--;            return t;        }        T &operator*() const{            return *s;        }        T *operator->() const{            return *s;        }        T &operator[](const int x){            return s[x];        }        bool operator==(const Iterator &x) const {            return x.s == s;        }        bool operator!=(const Iterator &x) const{            return x.s != s;        }        bool operator<(const Iterator &x) const {            return x.s < this->s;        }        bool operator>(const Iterator &x) const {            return x.s > this->s;        }        bool operator<=(const Iterator &x) const {            return x.s <= this->s;        }        bool operator>=(const Iterator &x) const {            return x.s >= this->s;        }        T operator-(const Iterator &x){            return (s - x.s);        }        Iterator operator+(const Iterator &x){            return (s + x.s);        }    };public:    Circle_buf() = default;    Circle_buf(int capacit): capacit(capacit){        head = 0;        tail = 0;        data = new T(capacit);    }    ~Circle_buf(){        delete[] data;    }    Iterator begin() const{        return Iterator(data + head);    }    Iterator end() const{        return Iterator(data + tail);    }    T &front() const{        return data[head];    }    T &back() const{        return data[tail - 1];    }    T operator[](int id){        return data[id % capacit];    }    void push_front(const T &x){        if (tail == capacit){            data[head] = x;            return;        }        for(int i = tail; i >= head; i--){            data[i + 1] = data[i];        }        data[head] = x;        tail++;        return;    }    void pop_front(){        data[head] = 0;        head++;    }    void push_back(const T &x){        if (tail == capacit) tail--;        if (tail == capacit + 1) tail -= 2;        data[tail] = x;        if (tail != capacit + 1) tail++;    }    void pop_back(){        data[tail] = 0;        tail--;    }    void resize(const int &n){        T *tmp = new T[n];        for (int i = 0; i < n; i++){            tmp[i] = i < capacit ? data[i] : 0;        }        delete[] data;        data = tmp;        capacit = n;    }    void push_into_place(Iterator it, T x){        for(auto i = Iterator(data + tail); i != it - 1; i--)            *(i + 1) = *i;        *it = x;    }    void pop_into_place(Iterator it, T x){        for(auto i = it; i != Iterator(data + head) - 1; i++)            *(i + 1) = *i;        *it = x;    }private:    int capacit;    T *data;    int head = 0;    int tail = 0;};
//// Created by Karina on 18.03.2023.//#ifndef UNTITLED18_TYPES_OF_DATA_H#define UNTITLED18_TYPES_OF_DATA_H#endif //UNTITLED18_TYPES_OF_DATA_H#include <cmath>#define SIZE 100struct Vector{    int a,b;};class Triangle {private:    int x1, y1;    int x2, y2;    int x3, y3;public:    Triangle (int _x1, int _y1, int _x2, int _y2, int _x3, int _y3){        x1 = _x1;        x2 = _x2;        x3 = _x3;        y1 = _y1;        y2 = _y2;        y3 = _y3;    }    bool operator==(Triangle &triangle) const{        return find_square() == triangle.find_square();    }    bool operator!=(const Triangle &triangle) const{        return !(this == &triangle);    }    bool operator>(const Triangle &triangle) const{        return find_square() > triangle.find_square();    }    bool operator<(const Triangle &triangle) const{        return find_square() < triangle.find_square();    }    void operator+(Vector vec){        this->x1 += vec.a; this->y1 += vec.b;        this->x2 += vec.a; this->y2 += vec.b;        this->x3 += vec.a; this->y3 += vec.b;    }    double find_square() const {        double square = 0.;        square += 0.5*(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2));        return abs(square);    }};class Massive {    int *arr;    int length;public:    explicit Massive(int size = SIZE);    static Massive &get_len(Massive &array){        array.length = sizeof(array.arr);    }    void operator+(const Massive &mass){        Massive arr2;        int k=0;        for (int i=0; i<sizeof(*this); i++) {            arr2.arr[i] = this->arr[i];            k++;        }        for (int i=k; i<sizeof(*this) + sizeof(mass); i++){            arr2.arr[i] = mass.arr[i - sizeof(*this)];        }    }    bool operator==(const Massive &mass) const{        if (this->length == mass.length){            return this->length == mass.length;        }    }    bool operator!=(const Massive &mass) const{        if (this->length != mass.length){            return this->length != mass.length;        }    }    bool operator>(const Massive &mass) const{        if (this->length > mass.length){            return this->length > mass.length;        }    }    bool operator<(const Massive &mass) const{        if (this->length < mass.length){            return this->length < mass.length;        }    }};Massive::Massive(int size) { // Конструктор для инициализации Massive    arr = new int[size];    length = sizeof(arr);}